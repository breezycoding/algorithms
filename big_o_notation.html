<script>
/***
    in big O, O stands for the function we are evaluating and the other argument is for the size of the input
    big O tells us how slow an algorithm program will run if the input size grows
        -changes in runtime of function if input lets say array grows
        -performance of algorithm
***/
/*
    CONSTANT RUNTIME
        Constant runtime is written in big O as "0(1)"-O of 1-
            -the runtime of this program is constant because as the input size of array increases, the number of operation performed is the same.we still log 2 elements of the array no matter how large the array is.
*/
function log(array){
    console.log(array[0]);
    console.log(array[1]);
}
log([1,2,3,4,5,6]);
log([1,2,3,4,5,6,7,8,67,44,56,11,10]);
/*
    LINEAR RUNTIME
        -we write it as "O (n)" or O of N
        -as the input size increases, runtime increases
        -runtime will increase proportionally to how much input increases.
        -if the array has 5 elements the operation takes 5 operation if 7, 7 opeation and so on.
        
*/
function log_all(array){
    for(var i = 0; i < array.length; i++){
        console.log(array[i]);
    }
}
log_all([1,2,3,4,5,6]);
log_all([6,3,4,5,2,3,2,1]);
log_all([6,3,4,5,2,3,2,1,7,4,6,7]);
    
/*
    EXPONENTIAL RUNTIME
    exponential time complexity
        -written as "O (n^2)" or O of n squared
        -not very efficient and performant
        -one input can increase the runtime exponentially.
        -basically it iterates on every possible combination in array
        -it loops through the whole array
        then every element it hits it goes through whole array and hits every element again so all possible pairs are made
*/
function add_and_log(array){
    for(var i = 0; i < array.length; i++){
        for(var j = 0; j < array.length; j++){
            console.log(array[i] + array[j]);
        }
    }
}
/*9 paires are logged out*/
add_and_log(["A", "B", "C"]);
/*16 pairs are logged out*/
add_and_log(["A", "B", "C", "D"]);
/*25 pairs are logged out*/
add_and_log(["A", "B", "C", "D", "E"]);
    
/*
    LOGARITHMIC RUNTIME
        -written as O(log n) or O of log n
        -example is binary search
        -2 parameters are needed, 1 is list that must be sorted in some way, 2nd input is single value that we want to search for in our array.
        -binary search has logarithmic runtime because with every operation performed we are cutting the input by half
        -this is good because even if we have large input we are only gonna look for a fraction of elements to find the one we are searching for
        -as our size of input grows the number of operation we will perform will not grow proportionally rather logarithmically
        -4000 elements = 12 operations
*/
function binary_search(array, key){
    var low = 0;
    var high = array.length - 1;
    var mid;
    var element;
    
    while(low <= high){
        mid = Math.floor((low + high) /2, 10);
        element = array[mid];
        if(element < key){
            low = mid + 1;
        }else if(element > key){
            high = mid - 1;
        }else{
            return mid;
        }
    }
    return -1;
}
console.log(binary_search([6,3,4,5,2,3,2,1,7,4,6,7,100], 4));
</script>